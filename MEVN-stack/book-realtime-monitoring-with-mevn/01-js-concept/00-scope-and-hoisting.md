# 자바스크립트 - 함수 스코프와 호이스팅

> [실시간 모니터링 시스템을 만들며 정복하는 MEVN](http://www.yes24.com/Product/Goods/104208010) 도서를 학습하며 정리한 내용입니다.

---

## 함수 스코프 개념

- 스코프는 현재 실행되고 있는 컨텍스트를 의미
- 컨텍스트 내에서 접근 가능한 변수의 범위 정도로 이해하고 넘어간다. (실행 컨텍스트는 나중에 따로 정리)
- ES6의 let과 const 가 나오기 전까지는 `var`를 이용하여 변수를 선언하였는데, var는 `함수 스코프`를 갖는다.

### 함수 스코프 및 호이스팅 예제

```js
function test() {
  var x = 10;
  
  console.log(y); // undefined

  if (x === 10) {
    var x = 100;
    var y = 10;
  }
  
  return x * y;
}

console.log(test()); // 1000
console.log(x); // ReferenceError
```

- 위 예제와 같이 함수 내에서 선언된 변수가 함수 안에서만 접근 가능한 범위를 함수 스코프라 한다.
  - test 내부의 변수 x는 처음에 10으로 초기화되어 있는데, var로 선언한 변수는 함수 스코프를 가지므로 if 문안에서 재할당이 되는 것을 확인할 수 있다.
  - y의 경우 함수 스코프 + **호이스팅**이 발생하여 함수의 최상단으로 끌어올려지게 되어 return의 결과값으로 활용되었다. 위 코드를 보면 함수의  최상단에서 y를 호출해도 에러가 나지않고 undefined가 출력되는 것을 확인할 수 있다.

### 호이스팅??

```js
console.log(test); // undefined

var test = "This is VAR!";

test = "JavaScript";

console.log(test); // JavaScript
```

- hoisting. 의미 그대로 끌어올리기, 들어올리기.
- 호이스팅은 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미
  - 모든 함수, 변수가 선언될 때 **해당 스코프의 최상단으로 끌어 올려지는 것** 같다하여 붙여진 이름
- 특히, var의 경우 호이스팅 되면서 `undefined`로 초기화되기 때문에 실행 순서상 선언 전에 호출해도 참조 오류가 발생하지 않는다. (위 예제의 경우 단순히 호이스팅을 확인하기 위해 전역 스코프에서 실행해보았다)

```js
printJavaScript(); // JavaScript!!

function printJavaScript() {
  console.log("JavaScript!!");
}
```

- 함수 선언도 코드의 실행 순서와 상관없이 호이스팅되는 것을 확인할 수 있다.

### 그럼 호이스팅 되는게 좋은게 아닌가??

- 호이스팅으로 인해 변수를 선언 전에도 사용할 수 있다. 최상단에서부터 접근이 가능해져 버리기 때문에 참조 오류도 발생하지 않아 구현하려는 로직이 예상치 못하게 작동될 가능성이 있다.
- 이러한 것을 방지하고자 나온 것이 `let`과 `const` 키워드 변수 선언 방식이며, 이 키워드를 통해 변수를 선언하도록 권장하고 있다.

---

## ES6의 let과 const

- 위 키워드들은 변수를 선언할 때 사용하는 키워드로 ES6에서 추가된 구문이다.
  - `let` : 블록 스코프를 가지는 변수를 선언. 선언 후 재할당이 가능하다.
  - `const` : 블록 스코프를 가지는 상수를 선언. 선언 후 재할당이 불가능하다. (항상 같은 값 === 상수)

### 블록 스코프

```js
{
  let a = 10;

  {
    console.log(a); // 10
    let b = 100;
    console.log(a * b); // 1000
  }

  console.log(b); // ReferenceError
}
```

- 블록(`{}`)문 내에서만 범위를 갖는다. (함수, if, for, while, try...catch, {} 등등등)
- 자신이 선언된 블록과 모든 하위 블록을 스코프로 가진다. 이 말이 언 뜻 보면 var와 비슷해보이지만, var는 자신을 선언한 함수가 기준이 되어 블록을 무시한 채 최상단에 올려진다.

### TDZ

```js
{
  // TDZ
  console.log(a); // ReferenceError
 
  // 선언 및 초기화
  let a = 10;
}
```

- Temporal Dead Zone (MDN에선 시간상 사각지대라고 표현)
- let, const, class 의 경우 초기화 전까지는 변수를 사용할 수 없다.
  - 선언 후 초기화 실행코드 전까지 해당 변수를 호출하는 범위를 TDZ라고 표현
  - 선언과 동시에 초기화가 되는 것을 막아 호이스팅이 일어나지 않는 것처럼 보이게 된다.
- 아래에 MDN 예제를 통해 더 살펴보기로 한다.

```js
{
    // TDZ가 스코프 맨 위에서부터 시작
    const func = () => console.log(letVar); // OK

    // TDZ 안에서 letVar에 접근하면 ReferenceError

    let letVar = 3; // letVar의 TDZ 종료
    func(); // TDZ 밖에서 호출함
}
```

- func 변수에는 letVar 라는 변수의 값을 출력하는 내용의 함수 표현식이 초기화되어 있다. letVar는 let 키워드로 func 변수 아래에서 선언되고 초기화 된다.
- const func 부터 let letVar 선언식 까지가 letVar가 갖는 TDZ가 된다.
- 즉, 이미 선언 및 초기화가 끝난 후(TDZ 범위를 벗어난 후) 관련 변수를 호출하게 되면 문제없이 참조가 가능하다. 만약 letVar 선언식 전에 letVar를 참조하게 될 경우 에러가 발생한다. (초기화가 일어나기 전에 참조하게 되면 TDZ 범위로 인식. 에러가 발생)

---

## 정리

- `var` vs `let, const` // `선언 및 초기화` vs `선언 - TDZ - 초기화`
- 변수를 선언함에 있어 사용하는 키워드(구문)에 따라 변수가 가지는 범위가 달라진다.
  - var : 함수 스코프
  - let, const : 블럭 스코프
- var냐 let, const냐에 따라 호이스팅될 때 참조할 수 있는 영역이 구분된다.
  - var : 자신이 선언된 함수 선언을 기준으로 최상단으로 호이스팅된다.
  - let, const : 자신이 선언된 블록 범위를 기준으로 하위 블록 범위까지 포함할 수 있다. 단, 초기화 이전에 호출 시에는 TDZ을 갖게 되어 참조가 불가능하며, 온전히 초기화가 이루어진 다음에 호출해야 정상적인 실행이 가능하다.

> 함수 스코프, 블럭 스코프 내용을 이해했다. 추 후에 나올 실행 컨텍스트와 어떻게 연관되는지 잘 살펴봐야 겠다.

---

**참고 자료**

- [MDN - 호이스팅](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)
- [TOAST UI - TDZ을 모른 채 자바스크립트 변수를 사용하지 말라](https://ui.toast.com/weekly-pick/ko_20191014)